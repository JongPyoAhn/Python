'''
문제설명
숙제 n개
숙제마다 나오는날, 마감되는 날, 걸리는 시간이 주어진다.
예제)
4
0 1 4
1 3 7
2 2 3
3 4 5
=>
4

하루 3시간 씩만 숙제를 한다고 가정하자.
0일은 당연히 3시간
1일은 A에 1시간, B에 2시간
2일은 C에 3시간(마감임박이니까 우선적으로 처리해준다)
3일은 B에 3시간
...
하루 3시간으로는 문제를 해결할 수 없다.
하루 4시간이면? 가능.

결국 문제는 모든 숙제를 끝내기 위해 내가 공부해야하는 시간의 '하한'을 구하는 문제

이 문제가 어려운 이유?
'하한'을 구하는 문제인데, 하루에 x = 10으로 정해져 있어도 이 시간으로 모든 숙제 다할 수 있어?
라는 질문조차 대답하기 어려워서 어려운 문제.
여러분이 하루 100시간에 20만개 숙제를 365일 동안 가능?
이 대답이 떠오르지 않으면 어렵게느껴질 수 밖에 없다. 하물며 ?시간이다.

풀이과정)
x(하루투자시간) = 짧을 수록 곤란, 길수록 널널 (시간이 많을 수록 편하다)
작을수록 힘들고 클수록 널널할 때 특징?
특정 시점 기준으로 이것보다 짧으면 불가능하고 길면 가능한 시점이 있다.
전형적인 이분탐색!!
경계에서 가능한쪽의 값이 우리가 원하는 정답.(이분탐색 접근이유)

시뮬레이션을 사용할건데, 시간을 어디에 투자할지 결정할 때 "얼마나 남았지?" 보다 언제 끝날지가 중요하다.
숙제하나가 내일(10시간) 끝나고, 하나는 모레(100시간) 끝난다.
두개 다 해야되면 시간이 결정요인에 의미가 없다.
빨리 끝내는데, 투자가 최선이다.

자료구조)
당장할 수 있는 숙제들을 담는 바구니
역할
1. 새 숙제 삽입 / 삭제
2. 가장빨리 마감되는 숙제 선정




범위 : n <= 200_000, 0 <= 일수 <= 364, h <= 1_000_000

'''

import sys
import heapq
si = sys.stdin.readline
n = int(si())
hw = [[] for i in range(365)]
for _ in range(n):
    s, e, c = map(int, si().split())
    hw[s].append((e, c)) #[들어온시간] = (끝나는 날, 걸리는시간)
def solve(x: int) -> bool:
    que = []
    for i in range(365):
        for j in hw[i]:
            heapq.heappush(que, j)
            
        status = x  
        
        while que and status > 0:
            e, h = que[0]
            if e < i:
                return False
            if status >= h: #숙제를 다 끝낼 수 있다.
                status -= h
                heapq.heappop(que)
            else: #숙제를 다 끝낼 수 없다.
                que[0] = (e, h - status)
                status = 0

    return not que
                
        
s, e, answer = 0, 1000000000, 0    
while s <= e:
    mid = (s + e) // 2
    if solve(mid):
        answer = mid
        e = mid - 1
    else:
        s = mid + 1
        
print(answer)
    


